using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Immutable;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;

namespace SDI.SCG;

[Generator]
internal class ServiceActivatorGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider(predicate: static (s, _) => IsSyntaxTargetForGeneration(s), transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx)).Where(static m => m is not null);

        var compilationAndClasses = context.CompilationProvider.Combine(provider.Collect());

        context.RegisterSourceOutput(compilationAndClasses, static (spc, source) => Execute(source.Left, source.Right, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node) => node is ClassDeclarationSyntax classDeclaration && classDeclaration.AttributeLists.Count > 0;

    private static ClassDeclarationSyntax GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;
        var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);

        if(classSymbol == null) return null;

        var hasServiceAttribute = classSymbol.GetAttributes() .Any(attr => attr.AttributeClass?.Name is "ServiceAttribute" or "Service");

        var hasServiceImplementationAttribute = classSymbol.GetAttributes().Any(attr => attr.AttributeClass?.Name is "ServiceImplementationAttribute" or "ServiceImplementation");

        return hasServiceAttribute || hasServiceImplementationAttribute ? classDeclaration : null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes, SourceProductionContext context)
    {
        if(classes.IsDefaultOrEmpty) return;

        foreach(var classDeclaration in classes)
        {
            var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);

            if(classSymbol == null) continue;

            try
            {
                var activatorCode = GenerateActivatorClass(classSymbol);
                context.AddSource($"{classSymbol.Name}_Activator.g.cs", SourceText.From(activatorCode, Encoding.UTF8));
            }
            catch(Exception ex)
            {
                context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("SG0001", "Error generating activator", "Error generating activator for {0}: {1}", "CodeGeneration", DiagnosticSeverity.Error, true), Location.None, classSymbol.Name, ex.Message));
            }
        }
    }

    private static string GenerateActivatorClass(INamedTypeSymbol serviceClass)
    {
        var constructor = FindSuitableConstructor(serviceClass);
        var parameters = constructor.Parameters;

        var namespaceName = serviceClass.ContainingNamespace.ToDisplayString();
        var className = serviceClass.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName}.Activating");
        sb.AppendLine("{");
        sb.AppendLine("    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute]");
        sb.AppendLine($"    internal sealed class {serviceClass.Name}_Activator : global::SDI.Abstraction.IServiceInstanceActivator");
        sb.AppendLine("    {");
        sb.AppendLine("        public object Activate(global::SDI.Abstraction.ServiceId requestedId, global::SDI.Abstraction.IServiceProvider provider)");
        sb.AppendLine("        {");

        sb.Append("            return new ").Append(className).Append('(');

        for(int i = 0; i < parameters.Length; i++)
        {
            if(i > 0) sb.Append(", ");

            var param = parameters[i];
            var paramType = param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            sb.Append($"global::SDI.Extensions.RequiredServiceProviderExtension.GetRequiredService<{paramType}>(provider)");
        }

        sb.AppendLine(");");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static IMethodSymbol FindSuitableConstructor(INamedTypeSymbol classSymbol)
    {
        var constructors = classSymbol.Constructors.Where(c => c.DeclaredAccessibility == Accessibility.Public).ToArray();

        if(constructors.Length == 0) throw new InvalidOperationException($"No public constructors found for service {classSymbol.Name}");

        var attributedConstructor = constructors.FirstOrDefault(c => c.GetAttributes().Any(attr => attr.AttributeClass?.Name is "ServiceConstructorAttribute" or "ServiceConstructor"));

        if(attributedConstructor != null) return attributedConstructor;

        var maxParamsConstructor = constructors.OrderBy(c => c.Parameters.Length).First();

        return maxParamsConstructor;
    }
}
